
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    [{"authors":null,"categories":null,"content":"Jie Li is a Ph.D. candidate in Computer Science at Texas Tech University, where he is a member of the Data-Intensive Scalable Computing Laboratory (DISCL) under the guidance of Dr. Yong Chen. Jie’s research interests lie in the areas of High-Performance Computing, Advanced Computer Architecture, and Parallel and Distributed Computing. Jie completed his Master of Science degree in Computer Science from Texas Tech University in 2019. Prior to that, he earned a bachelor’s degree in architecture.\n","date":1685034000,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1685052360,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"","publishdate":"0001-01-01T00:00:00Z","relpermalink":"","section":"authors","summary":"Jie Li is a Ph.D. candidate in Computer Science at Texas Tech University, where he is a member of the Data-Intensive Scalable Computing Laboratory (DISCL) under the guidance of Dr. Yong Chen.","tags":null,"title":"Jie Li","type":"authors"},{"authors":["Jie Li"],"categories":[],"content":"There are several online tutorials available on how to add custom instructions to the RISC-V GNU toolchain. Two notable examples are Hadi’s tutorial here and Vivek’s tutorial here. However, these tutorials do not cover situations that involve adding new register files to the architecture. Although such cases may be rare, they are still possible, as demonstrated by the xBGAS project here. This post provides a summary of the steps I followed to add custom instructions and register files to the RISC-V GNU toolchain in order to support the xBGAS architecture. The source code will be provided at the end of this post.\n1. The RISC-V Opcodes Tool. Before we modify the RISC-V GNU toolchain, we need to generate the MATCH and MASK hexadecimal values which will be used later. The RISC-V Opcodes Tool is a Python script that can generate the MATCH and MASK values for custom instructions. It can be found here. We clone the repository:\ngit clone https://github.com/riscv/riscv-opcodes In the unratified folder, we create a new file rv64_xbgas and add the following lines:\neld rd rs1 imm12 14..12=3 6..2=0x1D 1..0=3 eaddie rd rs1 imm12 14..12=7 6..2=0x1E 1..0=3 ... For the encoding syntax, you may refer to the README of the riscv-opcodes repository. After we add the instructions, we simply run make and the MATCH and MASK values can be found in the generated encoding.out.h file. For the xBGAS RISC-V extension, the MATCH and MASK values are like this:\n#define MATCH_EADDIE 0x707b #define MASK_EADDIE 0x707f #define MATCH_ELD 0x3077 #define MASK_ELD 0x707f ... DECLARE_INSN(eld, MATCH_ELD, MASK_ELD) DECLARE_INSN(eaddie, MATCH_EADDIE, MASK_EADDIE) ... 2. The RISC-V GNU/GCC Binutils. Modifying the GCC compiler itself is complex and not necessary in most cases. We only need to modify the binutils, which is a collection of binary utility tools developed by the GNU project. The binutils can be found here. We need to modify the following files:\ninclude/opcodes/riscv-opc.h include/opcode/riscv.h opcodes/riscv-opc.c opcodes/riscv-dis.c gas/config/tc-riscv.c 2.1 include/opcodes/riscv-opc.h In this file, we add #define and DECLARE_INSN elements we generated in the previous step and put them in the appropriate blocks. #define should be put before #endif /* RISCV_ENCODING_H */ and DECLARE_INSN should be put after #ifdef DECLARE_INSN.\nAdding the #define:\n/* xBGAS instructions */ #define MATCH_EADDI 0x607b #define MASK_EADDI 0x707f #define MATCH_EADDIE 0x707b #define MASK_EADDIE 0x707f ... Adding the DECLARE_INSN:\n/* xBGAS instructions. */ DECLARE_INSN(eaddi, MATCH_EADDI, MASK_EADDI) DECLARE_INSN(eaddie, MATCH_EADDIE, MASK_EADDIE) ... 2.2 include/opcode/riscv.h In this file, we add the following declarations:\nextern const char * const riscv_xbgas_names_numeric[NGPR]; riscv_xbgas_names_numeric is the data structure that stores the names of the new register files; we will define it in the next step. NGPR is MARCO of the number of registers in the register file. For the xBGAS extension, we have 32 registers in the register file.\n2.3 opcodes/riscv-opc.c At the beginning of this file, similar to other register names, we define the registers for xBGAS:\nconst char *const riscv_xbgas_names_numeric[NGPR] = { \u0026#34;e0\u0026#34;, \u0026#34;e1\u0026#34;, \u0026#34;e2\u0026#34;, \u0026#34;e3\u0026#34;, \u0026#34;e4\u0026#34;, \u0026#34;e5\u0026#34;, \u0026#34;e6\u0026#34;, \u0026#34;e7\u0026#34;, \u0026#34;e8\u0026#34;, \u0026#34;e9\u0026#34;, \u0026#34;e10\u0026#34;, \u0026#34;e11\u0026#34;, \u0026#34;e12\u0026#34;, \u0026#34;e13\u0026#34;, \u0026#34;e14\u0026#34;, \u0026#34;e15\u0026#34;, \u0026#34;e16\u0026#34;, \u0026#34;e17\u0026#34;, \u0026#34;e18\u0026#34;, \u0026#34;e19\u0026#34;, \u0026#34;e20\u0026#34;, \u0026#34;e21\u0026#34;, \u0026#34;e22\u0026#34;, \u0026#34;e23\u0026#34;, \u0026#34;e24\u0026#34;, \u0026#34;e25\u0026#34;, \u0026#34;e26\u0026#34;, \u0026#34;e27\u0026#34;, \u0026#34;e28\u0026#34;, \u0026#34;e29\u0026#34;, \u0026#34;e30\u0026#34;, \u0026#34;e31\u0026#34; }; The opcode or instruction definitions are in the riscv_opcodes array: const struct riscv_opcode riscv_opcodes[]. We add the following lines to the end of the array and before {0, 0, INSN_CLASS_NONE, 0, 0, 0, 0, 0}:\n/* xBGAS instructions */ {\u0026#34;eld\u0026#34;, 64, INSN_CLASS_I, \u0026#34;d,o(s)\u0026#34;, MATCH_ELD, MASK_ELD, match_opcode, 0 }, {\u0026#34;eaddie\u0026#34;, 64, INSN_CLASS_I, \u0026#34;G,s,o\u0026#34;, MATCH_EADDIE,MASK_EADDIE,match_opcode, 0 }, ... For the meaning of the fields in the riscv_opcode structure, you may refer to the structure definition in the include/opcode/riscv.h file.\n2.4 opcodes/riscv-dis.c We made the following changes in this file:\nAdd static const char * const *riscv_xbgas_names; to hold the register names usded by the disassembler. Add static const char * const *riscv_xbgas_names; in the set_default_riscv_dis_options function and the parse_riscv_dis_option_without_args function (after riscv_fpr_names = ...). In the print_insn_args function, we add the following lines to switch (*oparg):\ncase \u0026#39;H\u0026#39;: /* EXT1: xBGAS extended register */ print (info-\u0026gt;stream, dis_style_register, \u0026#34;%s\u0026#34;, riscv_xbgas_names[rs1]); break; case \u0026#39;J\u0026#39;: /* EXT2, xBGAS extended register */ print (info-\u0026gt;stream, dis_style_register, \u0026#34;%s\u0026#34;, riscv_xbgas_names[EXTRACT_OPERAND (RS2, l)]); break; case \u0026#39;G\u0026#39;: /* EXTD/EXT3, xBGAS extended register */ print (info-\u0026gt;stream, dis_style_register, \u0026#34;%s\u0026#34;, riscv_xbgas_names[rd]); break; The H, J and G will also be used in the next step.\n2.5 gas/config/tc-riscv.c In this file, we made the following changes.\nIn the reg_class enumeration, we add the RCLASS_XBGAS before …","date":1685034000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1685052360,"objectID":"5f990e6414371abc9f53109f6a08ae05","permalink":"https://lijie.me/post/adding-custom-instructions-to-riscv-gnu-toolchain/","publishdate":"2023-05-25T17:00:00Z","relpermalink":"/post/adding-custom-instructions-to-riscv-gnu-toolchain/","section":"post","summary":"There are several online tutorials available on how to add custom instructions to the RISC-V GNU toolchain. Two notable examples are Hadi’s tutorial here and Vivek’s tutorial here. However, these tutorials do not cover situations that involve adding new register files to the architecture.","tags":["RISC-V","xBGAS","GNU toolchain"],"title":"RISC-V GNU toolchain with custom instructions","type":"post"},{"authors":["Jie Li"],"categories":[],"content":"Prepare an USB Stick with 32-bit EFI and 64-bit Linux. Insert a usb stick and find its name on Mac. The following commands are used based on the stick name disk2:\ndiskutil list Write zero to the disk and quit the process after abut 10 seconds by Ctrl+c. Before running the following command, you may need to run diskutil unmountDisk /dev/disk2 to avoid Resource busy error.\nsudo dd if=/dev/zero of=/dev/disk2 Create an EFI partition on the stick using diskutil, format is set to MS-DOS(FAT) and Scheme is set to GUID Partition Map. Then check the EFI partition identifier via diskutil list. Suppose its identifier is disk2s1. Note that the EFI partitin is not mounted by macOS by default so you have to manually mount it by yourself:\nmkdir /tmp/sdb1 sudo mount -o rw -t msdos /dev/disk2s1 /tmp/sdb1 Create some folders in the EFI partition:\nsudo mkdir -p /tmp/sdb1/boot/grub/ sudo mkdir -p /tmp/sdb1/efi/boot/ Create grub.cfg file in /tmp/sdb1/boot/grub/ and write the following lines:\nsearch --file --set=root /boot/grub/loopback.cfg configfile /boot/grub/loopback.cfg Download a bootia32.efi:\nwget https://github.com/jfwells/linux-asus-t100ta/raw/master/boot/bootia32.efi Copy the bootia32.efi to /tmp/sdb1/efi/boot/ and then unmount the drive:\nsudo cp /path/to/bootia32.efi /tmp/sdb1/efi/boot/ Put the ISO image on the second partition (suppose its identifier is disk2s2). You may need to run diskutil unmountDisk /dev/disk2 to avoid Resource busy error:\nsudo dd if=/path/to/lubuntu.iso of=/dev/disk2s2 bs=1M. Install the OS. Insert the USB stick to the old Mac. Power on the machine and hold the Alt key until two drivers show on the screen. Choose the EFI and press Enter. Wait for a couple of seconds and some texts like “Try Lubuntu…” show up, then press e to edit the boot options. Change quiet splash to nomodest splash . This is the one I use, you may change it according to your needs. For more options: boot options. Press f10 to save the changes and start installing. References: ISO images can be found here: mattgadient.com. Adapt the method from Live CD on an USB Stick and adjust to the macOS environment. ","date":1675900800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1675900800,"objectID":"23015f3c89d93448ade8c1e88e6d4a1d","permalink":"https://lijie.me/post/revive-an-old-mac/","publishdate":"2023-02-09T00:00:00Z","relpermalink":"/post/revive-an-old-mac/","section":"post","summary":"Prepare an USB Stick with 32-bit EFI and 64-bit Linux. Insert a usb stick and find its name on Mac. The following commands are used based on the stick name disk2:","tags":["MacOS","32-bit","64-bit","EFI"],"title":"Revive An Old Mac","type":"post"},{"authors":["Tommy Dang","Ngan Nguyen","Jie Li","Alan Sill","Jon Hass","Yong Chen"],"categories":null,"content":" ","date":1670284800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1670284800,"objectID":"ef88ee8898b50772ecb72dedce5227fc","permalink":"https://lijie.me/publication/job-viewer-2022/","publishdate":"2023-03-13T00:00:00Z","relpermalink":"/publication/job-viewer-2022/","section":"publication","summary":"Visualization aims to strengthen data exploration and analysis, especially for complex and high-dimensional data. High-performance computing (HPC) systems are typically large and complicated instruments that generate massive performance and operation time series. Monitoring HPC systems’ performance is a daunting task for HPC admins and researchers due to their dynamic natures. This work proposes a visual design using the bipartite graph’s idea to visualize HPC clusters’ structure, metrics, and job scheduling data. We built a web-based prototype, called JobViewer, that integrates advanced methods in visualization and human-computer interaction (HCI) to demonstrate the benefits of visualization in real-time monitoring HPC centers. We also showed real use cases and a user study to validate the efficiency and highlight the current approach’s drawbacks.","tags":["HPC","Visualization","Graph","Monitoring","Data Analytics"],"title":"JobViewer: Graph-based Visualization for Monitoring High-Performance Computing System","type":"publication"},{"authors":["Jie Li","Ngan Nguyen","Jon Hass","Tommy Dang","Yong Chen","Alan Sill"],"categories":null,"content":" ","date":1636848000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1636848000,"objectID":"82786f030befb225a67be2e02d27cdae","permalink":"https://lijie.me/talk/advanced-visualization-and-data-analysis-of-hpc-cluster-and-user-application-behavior/","publishdate":"2021-11-12T00:00:00Z","relpermalink":"/talk/advanced-visualization-and-data-analysis-of-hpc-cluster-and-user-application-behavior/","section":"event","summary":"A Project Presentation at SC21.","tags":["HPC","Monitoring","Data Analysis","Visualization"],"title":"Advanced Visualization and Data Analysis of HPC Cluster and User Application Behavior","type":"event"},{"authors":["Tommy Dang","Ngan Nguyen","Jon Hass","Jie Li","Yong Chen","Alan Sill"],"categories":null,"content":" ","date":1633046400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1633046400,"objectID":"0e4c0a0568f8db07885cd38b6a2900b0","permalink":"https://lijie.me/publication/gap-2021/","publishdate":"2021-10-01T00:00:00Z","relpermalink":"/publication/gap-2021/","section":"publication","summary":"Visualizing and monitoring high-performance computing centers is a daunting task due to the systems’ complex and dynamic nature. Moreover, different users may have different requirements and needs. For example, computer scientists carry out data analysis as batch jobs using various models, configurations, and parameters, and they often need to manage jobs. System administrators need to monitor and manage the system constantly. In this paper, we discuss the gap between visual monitoring research and practical applicability. We will start with the general requirements for managing high-performance computing centers and then share the experiences working with academic and industrial experts in this domain.","tags":["HPC","Visualization","Monitoring","Data Analysis","Machine Learning"],"title":"The Gap between Visualization Research and Visualization Software in High-Performance Computing Center","type":"publication"},{"authors":["Xi Wang","Antonino Tumeo","John D. Leidel","Jie Li","Yong Chen"],"categories":null,"content":" ","date":1616025600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1616025600,"objectID":"f2a97bfcfca055642982296b83034381","permalink":"https://lijie.me/publication/ham-2021/","publishdate":"2021-06-01T00:00:00Z","relpermalink":"/publication/ham-2021/","section":"publication","summary":"Emerging High-Performance Computing (HPC) workloads, such as graph analytics, machine learning, and big data science, are data-intensive. Data-intensive workloads usually present fine-grained memory accesses with limited or no data locality, and thus incur frequent cache misses and low utilization of memory bandwidth. 3D-stacked memory devices such as Hybrid Memory Cube (HMC) and High Bandwidth Memory (HBM) can provide significantly higher bandwidth than conventional memory modules. However, the traditional interfaces and optimization methods for JEDEC DDR devices do not allow to fully exploit the potential performance of 3D-stacked memory with the massive amount of irregular memory accesses of data-intensive applications. In this article, we propose a novel Hotspot-Aware Manager (HAM) infrastructure for 3D-stacked memory devices capable of optimizing memory access streams via request aggregation, hotspot detection, and in-memory prefetching. We present the HAM design and implementation, and simulate it on a system using RISC-V embedded cores with attached HMC devices. We extensively evaluate HAM with over 12 benchmarks and applications representing diverse irregular memory access patterns. The results show that, on average, HAM reduces redundant requests by 37.51 percent and increases the prefetch buffer hit rate by 4.2 times, compared to a baseline streaming prefetcher. On the selected benchmark set, HAM provides performance gains of 21.81 percent in average (up to 34.28 percent), and power savings of 35.07 percent over a standard 3D-stacked memory.","tags":["HPC","3D-Stacked Memory","Memory Management","Prefetching","Hotspot Detection"],"title":"HAM: Hotspot-Aware Manager for Improving Communications with 3D-Stacked Memory","type":"publication"},{"authors":["Jie Li","Ghazanfar Ali","Ngan Nguyen","Jon Hass","Alan Sill","Tommy Dang","Yong Chen"],"categories":null,"content":" ","date":1600041600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1600041600,"objectID":"7405d90ba1e1b01e3deafbeb93181eff","permalink":"https://lijie.me/publication/monster-2020/","publishdate":"2020-11-02T00:00:00Z","relpermalink":"/publication/monster-2020/","section":"publication","summary":"Understanding the status of high-performance computing platforms and correlating applications to resource usage provide insight into the interactions among platform components. A lot of efforts have been devoted into developing monitoring solutions; however, a large-scale HPC system usually requires a combination of methods/tools to successfully monitor all metrics, which will lead to a huge effort in configuration and monitoring. Besides, monitoring tools are often left behind in the procurement of large-scale HPC systems. These challenges have motivated the development of a next-generation out-of-the-box monitoring tool that can be easily deployed without losing informative metrics. In this work, we introduce MonSTer, an “out-of-the-box” monitoring tool for high-performance computing platforms. MonSTer uses the evolving specification Redfish to retrieve sensor data from Baseboard Management Controller (BMC), and resource management tools such as Univa Grid Engine (UGE) or Slurm to obtain application information and resource usage data. Additionally, it also uses a time-series database (e.g. InfluxDB) for data storage. MonSTer correlates applications to resource usage and reveals insightful knowledge without having additional overhead on the application and computing nodes. This paper presents the design and implementation of MonSTer, as well as experiences gained through real-world deployment on the 467-node Quanah cluster at Texas Tech University’s High Performance Computing Center (HPCC) over the past year.","tags":["HPC","Monitoring","Redfish","InfluxDB","Data Analytics","Time-series Data Analytics"],"title":"MonSTer: an out-of-the-box monitoring tool for high performance computing systems","type":"publication"},{"authors":["Jie Li","Ghazanfar Ali","Ngan Nguyen","Jon Hass","Alan Sill","Tommy Dang","Yong Chen"],"categories":null,"content":" ","date":1600041600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1600041600,"objectID":"7ff41269c333ca915c2b6acfcce7ed0a","permalink":"https://lijie.me/talk/monster-an-out-of-the-box-monitoring-tool-for-high-performance-computing-systems/","publishdate":"2020-09-14T00:00:00Z","relpermalink":"/talk/monster-an-out-of-the-box-monitoring-tool-for-high-performance-computing-systems/","section":"event","summary":"A Conference Presentation for our paper \"MonSTer-An Out-of-the-Box Monitoring Tool for High Performance Computing Systems\" at CLUSTER 2019.","tags":["HPC","Monitoring","Redfish","InfluxDB","Data Analytics","Time-series Data Analytics"],"title":"MonSTer: An Out-of-the-Box Monitoring Tool for High Performance Computing Systems","type":"event"},{"authors":["Ngan Nguyen","Jon Hass","Yong Chen","Jie Li","Alan Sill","Tommy Dang"],"categories":null,"content":" ","date":1595721600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1595721600,"objectID":"447d428986e561caf6ff0ea25f18ce98","permalink":"https://lijie.me/publication/radar-viewer-2020/","publishdate":"2020-07-26T00:00:00Z","relpermalink":"/publication/radar-viewer-2020/","section":"publication","summary":"This showcase presents a visual approach based on clustering and superimposing to construct a high-level overview of sequential event data while balancing the amount of information and the cardinality in it. We also implement an interactive prototype, called RadarViewer , that allows domain analysts to simultaneously analyze sequence clustering, extract useful distribution patterns, drill multiple levels-of-detail to accelerate the analysis. The RadarViewer is demonstrated through case studies with real-world temporal datasets of different sizes.","tags":["HPC","Visualization","Monitoring","Data Analytics"],"title":"RadarViewer: Visualizing the dynamics of multivariate data","type":"publication"},{"authors":["Vung Pham","Ngan Nguyen","Jie Li","Jon Hass","Yong Chen","Tommy Dang"],"categories":null,"content":" ","date":1582502400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1582502400,"objectID":"f773fdd026e4421ae34c52ab3bd391a2","permalink":"https://lijie.me/publication/mtsad-2019/","publishdate":"2019-09-12T00:00:00Z","relpermalink":"/publication/mtsad-2019/","section":"publication","summary":"Detecting outliers is one of the fundamental tasks in visual analytics and valuable in many application domains, such as suspicious network cyberattack recognition. This paper introduces an approach to analyzing and visualizing highdimensional time series, focusing on identifying multivariate observations that are significantly different from the others. We also propose a prototype, called MTSAD, to guide users when interactively exploring abnormalities in large time series. The prototype contains two views: the main window provides an overview of identified outliers overtime, the detail window investigates and explores the ranked temporal data entries based on their outlying contributions to the overall plots. The visual interface supports a full range of interactions, such as lensing, brushing and linking, ranking, and filtering. To validate the benefits and usefulness of our approach, we demonstrate MTSAD on real-world datasets of different numbers of attributes.","tags":["HPC","Monitoring","Visualization","Time-series Data Analytics"],"title":"Mtsad: Multivariate time series abnormality detection and visualization","type":"publication"},{"authors":["Jie Li","Xi Wang","Antonino Tumeo","Brody Williams","John D. Leidel","Yong Chen"],"categories":null,"content":" ","date":1569888000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1569888000,"objectID":"3cfa59900fb9c5f38267e5732a85604d","permalink":"https://lijie.me/talk/pims-a-lightweight-processing-in-memory-accelerator-for-stencil-computations/","publishdate":"2019-10-01T00:00:00Z","relpermalink":"/talk/pims-a-lightweight-processing-in-memory-accelerator-for-stencil-computations/","section":"event","summary":"A Conference Presentation for our paper \"PIMS-A Lightweight Processing-In-Memory Accelerator for Stencil Computations\" at MEMSYS 2019.","tags":["Stencil","Processing-in-Memory","3D-Stacked Memory","Computer Architecture","HPC"],"title":"PIMS: A Lightweight Processing-In-Memory Accelerator for Stencil Computations","type":"event"},{"authors":["Jie Li","Xi Wang","Antonino Tumeo","Brody Williams","John D. Leidel","Yong Chen"],"categories":null,"content":" ","date":1569801600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1569801600,"objectID":"410bbb24205c5195078c79293ed0eb8b","permalink":"https://lijie.me/publication/pims-2019/","publishdate":"2019-09-01T00:00:00Z","relpermalink":"/publication/pims-2019/","section":"publication","summary":"Stencil computation is a classic computational kernel present in many high-performance scientific applications, like image processing and partial differential equation solvers (PDE). A stencil computation sweeps over a multi-dimensional grid and repeatedly updates values associated with points using the values from neighboring points. Stencil computations often employ large datasets that exceed cache capacity, leading to excessive accesses to the memory subsystem. As such, 3D stencil computations on large grid sizes are memory-bound. In this paper we present PIMS, an in-memory accelerator for stencil computations. PIMS, implemented in the logic layer of a 3D stacked memory, exploits the high bandwidth provided by through silicon vias to reduce redundant memory traffic. Our comprehensive evaluation using three different grid sizes with six categories of orders indicate that the proposed architecture reduces 48.25% of data movement on average and obtains up to 65.55% of bank conflict reduction.","tags":["Stencil","Processing-in-Memory","3D-Stacked Memory","Computer Architecture","HPC"],"title":"PIMS: a lightweight processing-in-memory accelerator for stencil computations","type":"publication"},{"authors":["Xi Wang","Antonino Tumeo","John D. Leidel","Jie Li","Yong Chen"],"categories":null,"content":" ","date":1564963200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564963200,"objectID":"9cdaecbdfc500d22e5083fa51abe635c","permalink":"https://lijie.me/publication/mac-2019/","publishdate":"2019-08-01T00:00:00Z","relpermalink":"/publication/mac-2019/","section":"publication","summary":"Emerging data-intensive applications, such as graph analytics and data mining, exhibit irregular memory access patterns. Research has shown that with these memory-bound applications, traditional cache-based processor architectures, which exploit locality and regular patterns to mitigate the memory-wall issue, are inefficient. Meantime, novel 3D-stacked memory devices, such as Hybrid Memory Cube (HMC) and High Bandwidth Memory (HBM), promise significant increases in bandwidth that appear extremely appealing for memory-bound applications. However, conventional memory interfaces designed for cache-based architectures and JEDEC DDR devices fit poorly with the 3D-stacked memory, which leads to significant under-utilization of the promised high bandwidth. As a response to these issues, in this paper we propose MAC (Memory Access Coalescer), a coalescing unit for the 3D-stacked memory. We discuss the design and implementation of MAC, in the context of a custom designed cache-less architecture targeted at data-intensive, irregular applications. Through a custom simulation infrastructure based on the RISC-V toolchain, we show that MAC achieves a coalescing efficiency of 52.85% on average. It improves the performance of the memory system by 60.73% on average for a large set of irregular workloads.","tags":["Computer Architecture","3D-stacked Memory","Memory Coalescing"],"title":"MAC: Memory access coalescer for 3D-stacked memory","type":"publication"},{"authors":[],"categories":[],"content":"Create slides in Markdown with Wowchemy Wowchemy | Documentation\nFeatures Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides Controls Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026#34;blueberry\u0026#34; if porridge == \u0026#34;blueberry\u0026#34;: print(\u0026#34;Eating...\u0026#34;) Math In-line math: $x + y = z$\nBlock math:\n$$ f\\left( x \\right) = ;\\frac{{2\\left( {x + 4} \\right)\\left( {x - 4} \\right)}}{{\\left( {x + 4} \\right)\\left( {x + 1} \\right)}} $$\nFragments Make content appear incrementally\n{{% fragment %}} One {{% /fragment %}} {{% fragment %}} **Two** {{% /fragment %}} {{% fragment %}} Three {{% /fragment %}} Press Space to play!\nOne Two Three A fragment can accept two optional parameters:\nclass: use a custom style (requires definition in custom CSS) weight: sets the order in which a fragment appears Speaker Notes Add speaker notes to your presentation\n{{% speaker_note %}} - Only the speaker can read these notes - Press `S` key to view {{% /speaker_note %}} Press the S key to view the speaker notes!\nOnly the speaker can read these notes Press S key to view Themes black: Black background, white text, blue links (default) white: White background, black text, blue links league: Gray background, white text, blue links beige: Beige background, dark text, brown links sky: Blue background, thin dark text, blue links night: Black background, thick white text, orange links serif: Cappuccino background, gray text, brown links simple: White background, black text, blue links solarized: Cream-colored background, dark green text, blue links Custom Slide Customize the slide style and background\n{{\u0026lt; slide background-image=\u0026#34;/media/boards.jpg\u0026#34; \u0026gt;}} {{\u0026lt; slide background-color=\u0026#34;#0000FF\u0026#34; \u0026gt;}} {{\u0026lt; slide class=\u0026#34;my-style\u0026#34; \u0026gt;}} Custom CSS Example Let’s make headers navy colored.\nCreate assets/css/reveal_custom.css with:\n.reveal section h1, .reveal section h2, .reveal section h3 { color: navy; } Questions? Ask\nDocumentation\n","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1549324800,"objectID":"0e6de1a61aa83269ff13324f3167c1a9","permalink":"https://lijie.me/slides/example/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/slides/example/","section":"slides","summary":"An introduction to using Wowchemy's Slides feature.","tags":[],"title":"Slides","type":"slides"},{"authors":null,"categories":null,"content":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.\nNullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.\nCras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.\nSuspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.\nAliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.\n","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"e8f8d235e8e7f2efd912bfe865363fc3","permalink":"https://lijie.me/project/example/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/project/example/","section":"project","summary":"An example of using the in-built project page.","tags":["Deep Learning"],"title":"Example Project","type":"project"},{"authors":null,"categories":null,"content":"","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"d1311ddf745551c9e117aa4bb7e28516","permalink":"https://lijie.me/project/external-project/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/project/external-project/","section":"project","summary":"An example of linking directly to an external project website using `external_link`.","tags":["Demo"],"title":"External Project","type":"project"}]